\htmlhr
\chapter{Nondeterminism Checker\label{nondeterminism-checker}}

A nondeterministic program is one that may produce different output when
run twice on the same input.  Nondeterministic programs are hard to debug
(it may be difficult to reproduce an incorrect behavior), and it is hard to
compare multiple outputs or logs.
Therefore, it is desirable for programs to be deterministic.
The Nondeterminism Checker helps you to achieve this goal.

Even single-threaded programs are frequently nondeterministic.
One cause is calls to Random, Date, and Time.
Another cause is use of hash tables (including \<HashSet>s and
\<HashMap>s), whose iteration order is nondeterministic across runs.
For example, even if the set contains the same values, the following code
may produce output in different orders:

\begin{Verbatim}
  for (Object x : mySet) {
    System.out.println(x);
  }
\end{Verbatim}

The Nondeterminism Checker enables a programmer to indicate which
computations should be the same across runs of a single-threaded program,
and then the Nondeterminism Checker verifies that property.

Another common cause of nondeterminism is the operating system scheduler,
for concurrent programs.  The Nondeterminism Checker does not address this
cause of nondeterminism.  Also, the Nondeterminism Checker does not warn
about the possibility that the file system contains different files or
contents on different runs of a program.

To run the Nondeterminism Checker, supply the
\code{-processor NondeterminismChecker}
command-line option to javac.
For example:

\begin{alltt}
  javac -processor NondeterminismChecker InputFile.java
\end{alltt}

%./bin/javac -cp NonDetTypeChecker/jsr308/checker-framework/checker/build -processor org.checkerframework.checker.nondeterminism.NondeterminismChecker NDCheckerTest/src/TestListUnsafe2.java


\section{Nondeterminism qualifiers\label{nondeterminism-qualifiers}}

The Nondeterminism type system uses the following type qualifiers (see Figure~\ref{fig-hierarchy}):
\begin{description}
\item[\refqualclass{checker/nondeterminism/qual}{ValueNonDet}] indicates
  that the expression might have different values in two different executions.
\item[\refqualclass{checker/nondeterminism/qual}{OrderNonDet}] applies only
  to collections, and indicates that the collection will have the same
  elements, but in a possibly different order, in two different executions.
\item[\refqualclass{checker/nondeterminism/qual}{Det}] indicates that
  the expression evaluates to the same value (up to equality) on all
  executions; for a collection, iteration yields the values in the same
  order.
  This is the default qualifier.
\end{description}

Section~\ref{nondeterminism-polymorphism} explains polymorphic qualifiers.

\begin{figure}
  \begin{center}
    \includeimage{nondet}{4cm}
  \end{center}
\caption{Type hierarchy}
\label{fig-hierarchy}
\end{figure}


\section{Valid collection types\label{nondeterminism-collection-types}}

The (nondeterminism) type of a Collection must be a supertype or equal to
the type of the type parameter.  For example, you may declare a
deterministic list of deterministic integers, but not a deterministic
list of nondeterministic integers.

For example, these types are valid:
\begin{itemize}
    \item \code{@Det List<@Det Integer>}
    \item \code{@ValueNonDet List<@OrderNonDet Set<@Det String>}\code{>}
\end{itemize}

These types are invald:
  \begin{itemize}
    \item \code{@Det Set<@ValueNonDetDet Integer>}
    \item \code{@OrderNonDet String}
  \end{itemize}

Figure~\ref{fig-nondeterminism-collections} illustrates the valid
relationships between collection types and type parameters.

\begin{figure}
  \centering
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    &   &  \multicolumn{3}{l|}{Type Parameter}                                                                       \\ \hline
    &             & ValueNonDet                                     & OrderNonDet              & Det \\ \cline{2-5}
              & ValueNonDet &                                                 &                          &     \\ \cline{2-5}
Collection    & OrderNonDet &   invalid  &                          &     \\ \cline{2-5}
              & Det         &   invalid               &    invalid  &     \\ \hline
  \end{tabular}
  \caption{Valid Collection declarations}
  \label{fig-nondeterminism-collections}
\end{figure}

%Formally, the type validity rule is stated as follows:

%\begin{prooftree}
%  \AxiomC{is\_Collection\_Type(tc)}
%  \AxiomC{outer\_type(tx) <= tc}
%  \BinaryInfC{|- : tc<tx> }
%\end{prooftree}

% \begin{verbatim}
% Type outer_type( Type tx )
% {
%     if ( ! is_Generic_type(tx) )
%         return tx
%     Assert (tx == ty<tz>)
%         return ty
% }
% \end{verbatim}


\section{Controlling polymorphism\label{nondeterminism-polymorphism}}

\begin{description}
\item[\refqualclass{checker/nondeterminism/qual}{PolyDet}] is a
  polymorphic qualifier over nondeterminism (see Section~\ref{qualifier-polymorphism}).
\end{description}

The Nondeterminism Checker makes
several enhancements to standerd polymorphic qualifiers.


\subsection{Replacing @OrderNonDet\label{nondeterminism-polymorphism-ordernondet}}

\begin{description}
\item[\refqualclass{checker/nondeterminism/qual}{Ond2D}]
  Applied to \<@PolyDet>,
  changes an \<@OrderNonDet> instantiation into \<@Det>.
\item[\refqualclass{checker/nondeterminism/qual}{Ond2Vnd}]
  Applied to \<@PolyDet>,
  changes an \<@OrderNonDet> instantiation into \<@ValueNonDet>.
\end{description}

Ordinarily, every occurrence of \<@PolyDet> is instantiated at the same
type.  Sometimes this does not capture the desired behavior.  For instance,
there should be three versions of the \<List.add> routine:

\begin{Verbatim}
   @ValueNonDet boolean add(@ValueNonDet List<E> this, E e)
           @Det boolean add(@OrderNonDet List<E> this, E e)
           @Det boolean add(        @Det List<E> this, E e)
\end{Verbatim}

A standard polymorphic annotation

\begin{Verbatim}
       @PolyDet boolean add(@PolyDet     List<E> this, E e)
\end{Verbatim}

\noindent
can express the first and third versions, but not the second one.  With an
\refqualclass{checker/nondeterminism/qual}{Ond2D} annotation, it is
possible to express all three:

\begin{Verbatim}
@Ond2D @PolyDet boolean add(@PolyDet     List<E> this, E e)
\end{Verbatim}

There is also an \refqualclass{checker/nondeterminism/qual}{Ond2Vnd}.

See the annotated JDK for more examples of the \<@Ond2D> and \<@Ond2Vnd>
annotations.


\subsection{Distinguishing bindings and uses\label{nondeterminism-polymorphism-binding}}

\begin{description}
\item[\refqualclass{checker/nondeterminism/qual}{UsePolyDet}]
  Has the same type as any \<@PolyDet> annotations in the method
  declaration, but does not affect their instantiation.
\end{description}

As explained in Section~\ref{qualifier-polymorphism},
all of the \<@PolyDet> annotations in a method declaration are given the same
instantiation, which is one that works for all of the actual arguments
(their least upper bound).

The \<@UsePolyDet> annotation is given the same instantiation as all of the
\<@PolyDet> annotations, but does not affect the instantiation.

As an example of the need for the \<@UsePolyDet> annotation, consider the
\<List.set> method.  There should be two versions of it (\<@OrderNonDet
int> is not a valid type, so no \<@OrderNonDet> instantiation is created):

\begin{Verbatim}
E set(@ValueNonDet List<E> this, @ValueNonDet int index, E element)
E set(        @Det List<E> this,         @Det int index, E element)
\end{Verbatim}

\noindent
However, it should \emph{not} be legal for a client to make a call such as
the following:

\begin{Verbatim}
@Det List<...> myDetList;
@ValueNonDet int random;
myDetList.set(random, ...);
\end{Verbatim}

\noindent
even though the arguments are legal for the first instantiation:
each argument type is a subtype of the corresponding declared type.
The type system must forbid this call, because it modifies a
\<@Det> list in a nondeterministic way.

To solve this problem, the instantiation is chosen based only on the first
argument (the \<List> argument).  To have this effect, the library method
annotation is annotated as:

\begin{Verbatim}
E set(    @PolyDet List<E> this,  @UsePolyDet int index, E element)
\end{Verbatim}



\section{How to customize the Nondeterminism Checker\label{nondeterminism-customization}}

In the JDK, printing methods such as \<println> are annotated as taking a
deterministic result.  This guarantees that a program's output will be
deterministic, but it may be too restrictive.  You can define your own
printing methods, some of which can take nondeterministic inputs.  You can
also override the JDK annotations by providing a stub file.


%%  LocalWords:  NondeterminismChecker
