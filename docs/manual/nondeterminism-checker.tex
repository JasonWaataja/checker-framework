\htmlhr
\chapter{Nondeterminism Checker\label{nondeterminism-checker}}
When a program produces diverging outputs across executions on the same input, developers
have a hard time debugging such programs.
The non-determinism checker identifies locations in source code that might result in different execution outcomes.
In particular, it checks for non-determinism that pertains to the use of Java Collections.
Consider the following example:
\begin{Verbatim}
	Set<Integer> st = new HashSet<Integer>();
	for(int i = 0 ; i < 10 ; i++)
	    st.add(i);
	Iterator<Integer> it = st.iterator();
	while(iterator.hasNext())
	    System.out.println(iterator.next());

\end{Verbatim}

The code above is non-deterministic because a HashSet is not ordered and its elements could be printed in different orders across executions.
On the other hand, certain Set functions like 'contains' always return deterministic results.

To run the Nondeterminism Checker, supply the
\code{-processor NonDeterminismChecker}
command-line option to javac.
For example:

\begin{alltt}
	javac -processor NonDeterminismChecker inputFile.java
\end{alltt}

%./bin/javac -cp NonDetTypeChecker/jsr308/checker-framework/checker/build -processor org.checkerframework.checker.nondeterminism.NonDeterminismChecker NDCheckerTest/src/TestListUnsafe2.java

\section{Nondeterminism annotations for collections\label{nondeterminism-annotations-collections}}

The Nondeterminism type system uses the following annotations:
\begin{itemize}
\item
  \refqualclass{checker/nondeterminism/qual}{ValueNonDet} indicates
  that the collection can have possibly different values in two different executions.
\item
  \refqualclass{checker/nondeterminism/qual}{OrderNonDet} indicates that
  the collection will have the same elements, but in a possibly different order in two different executions.
  \code{@ValueNonDet} is a supertype of \code{@OrderNonDet}.
 \item
  \refqualclass{checker/nondeterminism/qual}{Det} indicates that
  the collection will have the same elements, in the same order across all executions.
  \code{@OrderNonDet} is a supertype of \code{@Det}.
   It is the default qualifier.
\item
  \refqualclass{checker/nondeterminism/qual}{PolyDet and PolyDet2} are qualifiers that are
  polymorphic over nondeterminism (see Section~\ref{qualifier-polymorphism}).
\end{itemize}

\section{Nondeterminism annotations for all other types\label{nondeterminism-annotations-elements}}

\begin{itemize}
\item
  \refqualclass{checker/nondeterminism/qual}{ValueNonDet} indicates
  that this type can possibly have different values across different executions.
 \item
  \refqualclass{checker/nondeterminism/qual}{Det} indicates that
  the value remains the same in any execution.
\end{itemize}

Note that non-collections may not be annotated as \code{@OrderNonDet}

\begin{figure}
	\begin{center}
		\includeimage{nondet-hierarchy}{5cm}
	\end{center}
	\caption{Type hierarchy}
	\label{fig-ihierarchy}
\end{figure}

\section{Valid annotations on Collections\label{type-validity}}
The annotations on Collections must satisfy the constraint that the annotation on type parameter of a Collection must be a
subtype of the annotation on the Collection itself. Here are a few examples illustrating this.

\subsection{Examples\label{validity-examples}}
\begin{figure}[h]\caption{Valid types}
	\begin{enumerate}
		\item @Det List<@Det Integer>
		\item @ValueNonDet List<@OrderNonDet Set<@Det String>>
	\end{enumerate}
\end{figure}

\begin{figure}[h]\caption{Invalid types}
	\begin{enumerate}
		\item @Det Set<@ValueNonDetDet Integer> : The @Det annotation on Set means that iterating over its elements will produce the same elements in the exact same order across executions. But the @ValueNonDet annotation on Integer violates this guarantee. Therefore, this is an invalid type annotation.
		\item @ValueNonDet List<@OrderNonDet String> - This is invalid because @OrderNonDet can be used only with Collections but it is used with a String here.
	\end{enumerate}
\end{figure}

Table~\ref{Tab:validity} shows the valid annotations on Collections and their type parameters.
The Cells marked XXX are the invalid ones.
\begin{table}[h]
	\centering
	\caption{Valid Collections}
	\label{Tab:validity}
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		& 		\multicolumn{4}{l|}{Type Parameter}		                                                                   \\ \hline
		&             & ValueNonDet                                     & OrderNonDet              & Det \\ \cline{2-5}
		Collection    & ValueNonDet &                                                 &                          &     \\ \cline{2-5}
		& OrderNonDet &   XXX  &                          &     \\ \cline{2-5}
		& Det         &         XXX               &  	XXX	&     \\ \hline
	\end{tabular}
\end{table}

%Formally, the type validity rule is stated as follows:

%\begin{prooftree}
%	\AxiomC{is\_Collection\_Type(tc)}
%	\AxiomC{outer\_type(tx) <= tc}
%	\BinaryInfC{|- : tc<tx> }
%\end{prooftree}

\begin{verbatim}
Type outer\_type( Type tx )
{
    if ( ! is\_Generic\_type(tx) )
        return tx
    Assert (tx == ty<tz>)
        return ty
}
\end{verbatim}

\section{Method annotations\label{method-annotations}}
In addition to annotating the return type and the parameters of a method, users can supply the type annotations -
@Ond2D or @Ond2Vnd on method declarations.
If a return type is annotated as @Polydet, @Polydet gets resolved to @OrderNonDet, and the method declaration has a type annotation @Ond2D,
the checker replaces the return type from @OrderNonDet to @Det. Similarly, when the checker sees a type annotation @Ond2Vnd, it
replaces @OrderNonDet with @ValueNonDet. The next section illustrates how these annotations are used.

\section{Library Annotations\label{library-Annotations}}
\subsection{Methods common to Lists and Sets\label{lib-methods}}
In the type annotations that follow, @PolyDet and @PolyDet2 are polymorphic annotations.
\begin{description}
	\item[@Ond2D @PolyDet  boolean add (@PolyDet List <@PolyDet2 E> this, @PolyDet2 E e)] Suppose the List is of
	type @OrderNonDet List<@Det Integer>, this annotation ensures that the element to be added (E e) must be @Det. This is
	done with the help of @PolyDet2. The return type in this case will be annotated as @Det because of the @Ond2D annotation.
	\item[@ond2D @PolyDet  boolean contains (@PolyDet List <@PolyDet2 E> this, @PolyDet2 E e)]
	\item[@Ond2D @PolyDet int size (@PolyDet List <@PolyDet2 E> this)]
\end{description}

\section{Type system guarantess\label{type-system-guarantees}}
The underlying type system provides the following guarantees:
\begin{enumerate}
	\item Assignment from a subtype to a supertype is flagged as an error.
	\item The formal arguments to a method must be a subtypes of parameters in the declaration. Otherwise, the checker framework reports an error.
\end{enumerate}

\section{Checker guarantees\label{error-reporting}}
In addition to its usual type mismatch errors, the Nondeterminism checker reports the following:
\begin{enumerate}
	\item A \code{print} statement if any of its arguments has the type annotation @ValueNonDet or @OrderNonDet.
\end{enumerate}