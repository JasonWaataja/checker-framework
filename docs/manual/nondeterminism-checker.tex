\htmlhr
\chapter{Nondeterminism Checker\label{nondeterminism-checker}}

A nondeterministic program is one that may produce different output when
run twice on the same input.  Nondeterministic programs are hard to debug
(it may be difficult to reproduce an incorrect behavior), and it is hard to
compare multiple outputs or logs.

Even single-threaded programs are frequently nondeterministic.
One cause is calls to Random, Date, and Time.
Another cause is use of hash tables (including \<HashSet>s and
\<HashMap>s), whose iteration order is nondeterministic across runs.
For example, even if the set contains the same values, the following code
may produce output in different orders:

\begin{Verbatim}
  for (Object x : mySet) {
    System.out.println(x);
  }
\end{Verbatim}

The Nondeterminism Checker enables a programmer to indicate which
computations should be the same across runs of a single-threaded program,
and then the Nondeterminism Checker verifies that property.

Another common cause of nondeterminism is the operating system scheduler,
for concurrent programs.  The Nondeterminism Checker does not address this
cause of nondeterminism.  Also, the Nondeterminism Checker does not warn
about the possibility that the file system contains different files or
contents on different runs of a program.

To run the Nondeterminism Checker, supply the
\code{-processor NondeterminismChecker}
command-line option to javac.
For example:

\begin{alltt}
  javac -processor NondeterminismChecker inputFile.java
\end{alltt}

%./bin/javac -cp NonDetTypeChecker/jsr308/checker-framework/checker/build -processor org.checkerframework.checker.nondeterminism.NondeterminismChecker NDCheckerTest/src/TestListUnsafe2.java


\section{Nondeterminism annotations\label{nondeterminism-annotations}}

The Nondeterminism type system uses the following annotations (see Figure~\ref{fig-hierarchy}):
\begin{description}
\item[\refqualclass{checker/nondeterminism/qual}{ValueNonDet}] indicates
  that the expression might have different values in two different executions.
\item[\refqualclass{checker/nondeterminism/qual}{OrderNonDet}] applies only
  to collections, and indicates that the collection will have the same
  elements, but in a possibly different order, in two different executions.
  \code{@ValueNonDet} is a supertype of \code{@OrderNonDet}.
\item[\refqualclass{checker/nondeterminism/qual}{Det}] indicates that
  the expression evaluates to the same value (up to equality) on all executions.
  This is the default qualifier.
\item[\refqualclass{checker/nondeterminism/qual}{PolyDet}] is a
  polymorphic qualifier over nondeterminism (see Section~\ref{qualifier-polymorphism}).
\end{description}

\begin{figure}
  \begin{center}
    \includeimage{nondet}{4cm}
  \end{center}
\caption{Type hierarchy}
\label{fig-hierarchy}
\end{figure}


\section{Declaring Collections\label{nondeterminism-type-validity}}

The (nondeterminism) type of a Collection must be a supertype or equal to
the type of the type parameter.  For example, you may declare a
deterministic list of deterministic integers, but not a non-deterministic
list of deterministic integer.

These types are valid:
\begin{itemize}
    \item \code{@Det List<@Det Integer>}
    \item \code{@ValueNonDet List<@OrderNonDet Set<@Det String> >}
\end{itemize}

These types are invald:
  \begin{itemize}
    \item \code{@Det Set<@ValueNonDetDet Integer>}
    \item \code{@OrderNonDet String}
  \end{itemize}

Figure~\ref{fig-nondeterminism-collections} illustrates the valid
relationships between collection types and type parameters.

\begin{figure}
  \centering
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    &   &  \multicolumn{3}{l|}{Type Parameter}                                                                       \\ \hline
    &             & ValueNonDet                                     & OrderNonDet              & Det \\ \cline{2-5}
              & ValueNonDet &                                                 &                          &     \\ \cline{2-5}
Collection    & OrderNonDet &   invalid  &                          &     \\ \cline{2-5}
              & Det         &   invalid               &    invalid  &     \\ \hline
  \end{tabular}
  \caption{Valid Collection declarations}
  \label{fig-nondeterminism-collections}
\end{figure}

%Formally, the type validity rule is stated as follows:

%\begin{prooftree}
%  \AxiomC{is\_Collection\_Type(tc)}
%  \AxiomC{outer\_type(tx) <= tc}
%  \BinaryInfC{|- : tc<tx> }
%\end{prooftree}

% \begin{verbatim}
% Type outer_type( Type tx )
% {
%     if ( ! is_Generic_type(tx) )
%         return tx
%     Assert (tx == ty<tz>)
%         return ty
% }
% \end{verbatim}


\section{Method annotations\label{nondeterminism-method-annotations}}
In addition to annotating the return type and the parameters of a method, users can supply the type annotations -
@Ond2D or @Ond2Vnd on method declarations.
If a return type is annotated as @Polydet and if this @Polydet gets resolved to @OrderNonDet, and if the method declaration has a type annotation @Ond2D,
the checker replaces the return type from @OrderNonDet to @Det. Similarly, when the checker sees a type annotation @Ond2Vnd, it
replaces @OrderNonDet with @ValueNonDet. The next section illustrates how these annotations are used.

\section{Library Annotations\label{nondeterminism-library-annotations}}
\subsection{Methods common to Lists and Sets\label{lib-methods}}
\begin{description}
  \item[@Ond2D @PolyDet  boolean add (@PolyDet List <E> this, E e)] Suppose the List is of
  type @OrderNonDet List<@Det Integer>, the element to be added (E e) must be a subtype of @Det.
  The return type in this case will be annotated as @Det because of the @Ond2D annotation.
  \item[@Ond2D @PolyDet  boolean contains (@PolyDet List <E> this, E e)]
  \item[@Ond2D @PolyDet int size (@PolyDet List <E> this)]
\end{description}

\section{Type system guarantess\label{nondeterminism-type-system-guarantees}}
The underlying type system provides the following guarantees:
\begin{enumerate}
  \item Assignment from a subtype to a supertype is flagged as an error.
  \item The formal arguments to a method must be a subtypes of parameters in the declaration. Otherwise, the checker framework reports an error.
\end{enumerate}

\section{Checker guarantees\label{nondeterminism-error-reporting}}
In addition to its usual type mismatch errors, the Nondeterminism checker reports the following:
\begin{enumerate}
  \item A \code{print} statement flags an error if any of its arguments has the type annotation @ValueNonDet or @OrderNonDet.
\end{enumerate}

%%  LocalWords:  NondeterminismChecker
